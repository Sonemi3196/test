            const [tapEffects, setTapEffects] = useState([]);
            const [bonusTexts, setBonusTexts] = useState([]);
            const [language, setLanguage] = useState('ko'); // 'ko' ë˜ëŠ” 'ja'
            
            const goodEmoji = "ğŸ‡¯ğŸ‡µ";
            const badEmoji = "ğŸ‡°ğŸ‡·";
            
            const gameIntervalRef = useRef(null);
            const characterTimersRef = useRef({});
            const gameAreaRef = useRef(null);

            // ë‹¤êµ­ì–´ í…ìŠ¤íŠ¸
            const texts = {
                ko: {
                    title: "ğŸï¸ ë…ë„ ë°©ì–´ ê²Œì„ ğŸï¸",
                    score: "ì ìˆ˜",
                    timeLeft: "ë‚¨ì€ ì‹œê°„",
                    stage: "ìŠ¤í…Œì´ì§€",
                    clearCondition: "0ì  ì´ìƒìœ¼ë¡œ í´ë¦¬ì–´",
                    current: "í˜„ì¬",
                    max: "ìµœëŒ€",
                    gameReady: "ê²Œì„ ì¤€ë¹„ ì™„ë£Œ!",
                    startButton: "ê²Œì„ ì‹œì‘",
                    pressStart: "ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘",
                    stageCleared: "ğŸ‰ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´! ğŸ‰",
                    stageClearMsg: "0ì  ì´ìƒì„ ìœ ì§€í•˜ì—¬ í´ë¦¬ì–´í–ˆìŠµë‹ˆë‹¤!",
                    nextStage: "ë‹¤ìŒ ìŠ¤í…Œì´ì§€ë¡œ",
                    allClear: "ğŸ† ì „ì²´ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´! ğŸ†",
                    congratulations: "ì¶•í•˜í•©ë‹ˆë‹¤!",
                    gameOver: "ğŸ’€ ê²Œì„ ì˜¤ë²„ ğŸ’€",
                    timeUp: "ì‹œê°„ ì¢…ë£Œ!",
                    zeroScore: "0ì ìœ¼ë¡œ ê²Œì„ ì˜¤ë²„",
                    remaining: "ë‚¨ìŒ",
                    reset: "ë¦¬ì…‹",
                    howToPlay: "ê²Œì„ ë°©ë²•",
                    characters: "ìºë¦­í„°:",
                    targetToHit: "ì²˜ì¹˜ ëŒ€ìƒ",
                    absoluteAvoid: "ì ˆëŒ€ íšŒí”¼",
                    hitPoints: "+20~40ì  / ë†“ì¹˜ë©´ -200ì ",
                    instantZero: "ë°Ÿìœ¼ë©´ ì¦‰ì‹œ 0ì ",
                    rule1: "â€¢ ğŸ‡¯ğŸ‡µë¥¼ ì²˜ì¹˜í•˜ë©´ +20~40ì , ë†“ì¹˜ë©´ -200ì ì˜ ëŒ€í­ ê°ì ",
                    rule2: "â€¢ ğŸ‡°ğŸ‡·ë¥¼ ë°Ÿìœ¼ë©´ ì¦‰ì‹œ 0ì  (í•œ ë°©ì— ê²Œì„ ì˜¤ë²„)",
                    rule3: "â€¢ ì ìˆ˜ê°€ 0ì´ ë˜ëŠ” ìˆœê°„ ê²Œì„ ì˜¤ë²„",
                    rule4: "â€¢ ìŠ¤í…Œì´ì§€ê°€ ì˜¬ë¼ê°ˆìˆ˜ë¡ ğŸ‡¯ğŸ‡µì˜ ì´ë™ ì†ë„ê°€ ë¹¨ë¼ì§",
                    rule5: "â€¢ ì œí•œ ì‹œê°„ì´ ì§§ì•„ ë§¤ìš° ì „ëµì ì¸ í”Œë ˆì´ í•„ìš”",
                    rule6: "â€¢ ì œí•œ ì‹œê°„ ë‚´ì— ì ìˆ˜ê°€ 1ì  ì´ìƒ ë‚¨ìœ¼ë©´ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´",
                    bonusTexts: ["ëŒ€í•œë¯¼êµ­ ë§Œì„¸", "ì¼ë³¸ ì£½ì–´ë¼", "ì‚¬ìŠ¤ê°€", "ìµ¸ì•„", "ë§Œì„¸"]
                },
                ja: {
                    title: "ğŸï¸ ç‹¬å³¶é˜²è¡›ã‚²ãƒ¼ãƒ  ğŸï¸",
                    score: "ã‚¹ã‚³ã‚¢",
                    timeLeft: "æ®‹ã‚Šæ™‚é–“",
                    stage: "ã‚¹ãƒ†ãƒ¼ã‚¸",
                    clearCondition: "0ç‚¹ä»¥ä¸Šã§ã‚¯ãƒªã‚¢",
                    current: "ç¾åœ¨",
                    max: "MAX",
                    gameReady: "ã‚²ãƒ¼ãƒ æº–å‚™å®Œäº†ï¼",
                    startButton: "ã‚²ãƒ¼ãƒ é–‹å§‹",
                    pressStart: "ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ",
                    stageCleared: "ğŸ‰ ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ ğŸ‰",
                    stageClearMsg: "0ç‚¹ä»¥ä¸Šã‚’ç¶­æŒã—ã¦ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼",
                    nextStage: "æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸",
                    allClear: "ğŸ† å…¨ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ ğŸ†",
                    congratulations: "ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼",
                    gameOver: "ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ ğŸ’€",
                    timeUp: "æ™‚é–“åˆ‡ã‚Œï¼",
                    zeroScore: "ã‚¹ã‚³ã‚¢0ç‚¹ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼",
                    remaining: "æ®‹ã‚Š",
                    reset: "ãƒªã‚»ãƒƒãƒˆ",
                    howToPlay: "ã‚²ãƒ¼ãƒ ã®éŠã³æ–¹",
                    characters: "ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼:",
                    targetToHit: "è¨ã¡å–ã‚‹å¯¾è±¡",
                    absoluteAvoid: "çµ¶å¯¾é¿ã‘ã‚‹",
                    hitPoints: "+20~40ç‚¹ / é€ƒã™ã¨-200ç‚¹",
                    instantZero: "è¸ã‚€ã¨å³åº§ã«0ç‚¹",
                    rule1: "â€¢ ğŸ‡¯ğŸ‡µã‚’è¨ã¡å–ã‚‹ã¨+20~40ç‚¹ã€é€ƒã™ã¨-200ç‚¹ã®å¤§å¹…æ¸›ç‚¹",
                    rule2: "â€¢ ğŸ‡°ğŸ‡·ã‚’è¸ã‚€ã¨å³åº§ã«0ç‚¹ï¼ˆä¸€ç™ºã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼‰",
                    rule3: "â€¢ ã‚¹ã‚³ã‚¢ãŒ0ã«ãªã£ãŸç¬é–“ã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼",
                    rule4: "â€¢ ã‚¹ãƒ†ãƒ¼ã‚¸ãŒä¸ŠãŒã‚‹ã«ã¤ã‚Œã¦ğŸ‡¯ğŸ‡µã®ç§»å‹•é€Ÿåº¦ãŒä¸ŠãŒã‚‹",
                    rule5: "â€¢ åˆ¶é™æ™‚é–“ãŒçŸ­ãã€éå¸¸ã«æˆ¦ç•¥çš„ãªãƒ—ãƒ¬ã‚¤ãŒå¿…è¦",
                    rule6: "â€¢ åˆ¶é™æ™‚é–“å†…ã«ã‚¹ã‚³ã‚¢ãŒ1ç‚¹ä»¥ä¸Šæ®‹ã‚Œã°ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢",
                    bonusTexts: ["ï¾ƒï¾Šï¾ï¾ï¾ï½¸ï¾ï½¸ï¾ï¾ï½¾", "ï½²ï¾™ï¾ï¾ï¾ï¾ï½­ï½ºï¾ï¾—", "ï½»ï½½ï½¶ï¾", "ï¾ï½®ï½±", "ï¾ï¾ï½¾"]
                }
            };

            const t = texts[language];<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‹¬å³¶é˜²è¡›ã‚²ãƒ¼ãƒ </title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap');
        body {
            font-family: 'Noto Sans JP', sans-serif;
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // Lucide React ã‚¢ã‚¤ã‚³ãƒ³ã®ä»£æ›¿å®Ÿè£…
        const Play = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor">
                <polygon points="5,3 19,12 5,21" />
            </svg>
        );
        
        const RotateCcw = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="1,4 1,10 7,10" />
                <path d="M3.51,15a9,9,0,0,0,13.83-6.36A9,9,0,0,0,3.51,15Z" />
            </svg>
        );

        const FlySwatterGame = () => {
            const [score, setScore] = useState(500);
            const [timeLeft, setTimeLeft] = useState(20);
            const [stage, setStage] = useState(1);
            const [gameStatus, setGameStatus] = useState('setup');
            const [characters, setCharacters] = useState([]);
            const [stageTarget, setStageTarget] = useState(0);
            const [whackedPositions, setWhackedPositions] = useState([]);
            const [tapEffects, setTapEffects] = useState([]);
            const [bonusTexts, setBonusTexts] = useState([]);
            
            const goodEmoji = "ğŸ‡¯ğŸ‡µ";
            const badEmoji = "ğŸ‡°ğŸ‡·";
            
            const gameIntervalRef = useRef(null);
            const characterTimersRef = useRef({});
            const gameAreaRef = useRef(null);

            const stageConfig = {
                1: { startScore: 500, maxScore: 1000, time: 20, spawnRate: 1000, maxCharacters: 6 },
                2: { startScore: 700, maxScore: 1400, time: 25, spawnRate: 900, maxCharacters: 8 },
                3: { startScore: 900, maxScore: 1800, time: 30, spawnRate: 800, maxCharacters: 10 },
                4: { startScore: 1100, maxScore: 2200, time: 35, spawnRate: 700, maxCharacters: 12 },
                5: { startScore: 1300, maxScore: 2600, time: 40, spawnRate: 600, maxCharacters: 15 }
            };

            const getRandomPosition = () => {
                const margin = 50;
                const x = Math.random() * (400 - margin * 2) + margin;
                const y = Math.random() * (400 - margin * 2) + margin;
                return { x, y };
            };

            const moveCharacter = (characterId) => {
                setCharacters(prev => prev.map(char => {
                    if (char.id === characterId) {
                        const newPosition = getRandomPosition();
                        return { ...char, ...newPosition };
                    }
                    return char;
                }));
            };

            const continuousMove = (characterId) => {
                const moveStep = () => {
                    setCharacters(prev => prev.map(char => {
                        if (char.id === characterId && char.type === 'bad') {
                            const deltaX = (Math.random() - 0.5) * 30;
                            const deltaY = (Math.random() - 0.5) * 30;
                            
                            const margin = 50;
                            const newX = Math.max(margin, Math.min(350, char.x + deltaX));
                            const newY = Math.max(margin, Math.min(350, char.y + deltaY));
                            
                            return { ...char, x: newX, y: newY };
                        }
                        return char;
                    }));
                };
                return setInterval(moveStep, 100);
            };

            const spawnCharacter = () => {
                const config = stageConfig[stage];
                if (characters.length >= config.maxCharacters) return;

                const isGoodCharacter = Math.random() > 0.5;
                const points = isGoodCharacter ? Math.floor(Math.random() * 20) + 20 : 0;
                const position = getRandomPosition();
                const newCharacter = {
                    id: Date.now() + Math.random(),
                    type: isGoodCharacter ? 'good' : 'bad',
                    points,
                    ...position,
                    createdAt: Date.now()
                };

                setCharacters(prev => [...prev, newCharacter]);

                let moveTimer, continuousTimer;

                if (isGoodCharacter) {
                    const baseSpeed = 800 - (stage - 1) * 150;
                    const randomVariation = Math.random() * 200;
                    const moveSpeed = Math.max(200, baseSpeed + randomVariation);
                    
                    moveTimer = setInterval(() => {
                        if (gameStatus === 'playing') {
                            moveCharacter(newCharacter.id);
                        }
                    }, moveSpeed);
                } else {
                    continuousTimer = continuousMove(newCharacter.id);
                }

                const removeTimer = setTimeout(() => {
                    setCharacters(prev => {
                        const character = prev.find(char => char.id === newCharacter.id);
                        if (character && character.type === 'good') {
                            setScore(current => Math.max(0, current - 200));
                        }
                        return prev.filter(char => char.id !== newCharacter.id);
                    });
                    if (moveTimer) clearInterval(moveTimer);
                    if (continuousTimer) clearInterval(continuousTimer);
                }, isGoodCharacter ? 4000 + Math.random() * 2000 : 10000 + Math.random() * 5000);

                characterTimersRef.current[newCharacter.id] = { 
                    moveInterval: moveTimer || continuousTimer, 
                    removeTimer 
                };
            };

            const catchCharacter = (character) => {
                if (gameStatus !== 'playing') return;

                const hitEffect = { x: character.x, y: character.y, id: Date.now() };
                setWhackedPositions(prev => [...prev, hitEffect]);
                
                setTimeout(() => {
                    setWhackedPositions(prev => prev.filter(pos => pos.id !== hitEffect.id));
                }, 600);

                if (character.type === 'good') {
                    const config = stageConfig[stage];
                    const newScore = Math.min(config.maxScore, score + character.points);
                    setScore(newScore);
                    
                    const randomText = t.bonusTexts[Math.floor(Math.random() * t.bonusTexts.length)];
                    
                    const appearTime = Date.now() - character.createdAt;
                    if (appearTime < 1000) {
                        const bonusTextEffect = { 
                            x: character.x, 
                            y: character.y - 50, 
                            id: Date.now() + Math.random(),
                            text: randomText
                        };
                        setBonusTexts(prev => [...prev, bonusTextEffect]);
                        
                        setTimeout(() => {
                            setBonusTexts(prev => prev.filter(bonus => bonus.id !== bonusTextEffect.id));
                        }, 1500);
                    }
                } else {
                    setScore(0);
                }

                setCharacters(prev => prev.filter(char => char.id !== character.id));

                if (characterTimersRef.current[character.id]) {
                    clearInterval(characterTimersRef.current[character.id].moveInterval);
                    clearTimeout(characterTimersRef.current[character.id].removeTimer);
                    delete characterTimersRef.current[character.id];
                }
            };

            const handleGameAreaClick = (event) => {
                if (gameStatus !== 'playing') return;

                const rect = gameAreaRef.current.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                const tapEffect = { x, y, id: Date.now() + Math.random() };
                setTapEffects(prev => [...prev, tapEffect]);
                
                setTimeout(() => {
                    setTapEffects(prev => prev.filter(effect => effect.id !== tapEffect.id));
                }, 500);
            };

            const startGame = () => {
                const config = stageConfig[stage];
                setScore(config.startScore);
                setTimeLeft(config.time);
                setStageTarget(0);
                setGameStatus('playing');

                gameIntervalRef.current = setInterval(() => {
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            setGameStatus('gameOver');
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
            };

            const resetGame = () => {
                setScore(500);
                setStage(1);
                setCharacters([]);
                setWhackedPositions([]);
                setTapEffects([]);
                setBonusTexts([]);
                setGameStatus('setup');
                if (gameIntervalRef.current) {
                    clearInterval(gameIntervalRef.current);
                }
                Object.values(characterTimersRef.current).forEach(timers => {
                    clearInterval(timers.moveInterval);
                    clearTimeout(timers.removeTimer);
                });
                characterTimersRef.current = {};
            };

            const nextStage = () => {
                setStage(prev => prev + 1);
                setCharacters([]);
                setWhackedPositions([]);
                setTapEffects([]);
                setBonusTexts([]);
                setGameStatus('setup');
                if (gameIntervalRef.current) {
                    clearInterval(gameIntervalRef.current);
                }
                Object.values(characterTimersRef.current).forEach(timers => {
                    clearInterval(timers.moveInterval);
                    clearTimeout(timers.removeTimer);
                });
                characterTimersRef.current = {};
            };

            useEffect(() => {
                let spawnInterval;
                
                if (gameStatus === 'playing') {
                    const config = stageConfig[stage];
                    spawnInterval = setInterval(() => {
                        spawnCharacter();
                    }, config.spawnRate);
                }

                return () => {
                    if (spawnInterval) {
                        clearInterval(spawnInterval);
                    }
                };
            }, [gameStatus, stage, characters.length]);

            useEffect(() => {
                if (gameStatus === 'gameOver') {
                    if (gameIntervalRef.current) {
                        clearInterval(gameIntervalRef.current);
                    }
                    Object.values(characterTimersRef.current).forEach(timers => {
                        clearInterval(timers.moveInterval);
                        clearTimeout(timers.removeTimer);
                    });
                    characterTimersRef.current = {};

                    if (score > 0) {
                        setGameStatus('stageCleared');
                    }
                }
            }, [gameStatus, score, stageTarget]);

            useEffect(() => {
                if (gameStatus === 'playing' && score <= 0) {
                    setGameStatus('gameOver');
                }
            }, [score, gameStatus]);

            return React.createElement('div', { className: "min-h-screen bg-gradient-to-b from-green-800 to-green-900 p-4" },
                React.createElement('div', { className: "max-w-4xl mx-auto" },
                    React.createElement('div', { className: "bg-white rounded-lg shadow-lg p-6 mb-6" },
                        React.createElement('h1', { className: "text-3xl font-bold text-center text-green-700 mb-4" }, 
                            "ğŸï¸ ç‹¬å³¶é˜²è¡›ã‚²ãƒ¼ãƒ  ğŸï¸"
                        ),
                        React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-3 gap-4 mb-6" },
                            React.createElement('div', { className: "bg-blue-100 p-3 rounded-lg" },
                                React.createElement('div', { className: "text-2xl font-bold text-blue-600" }, score),
                                React.createElement('div', { className: "text-sm text-blue-500" }, "ã‚¹ã‚³ã‚¢")
                            ),
                            React.createElement('div', { className: "bg-purple-100 p-3 rounded-lg" },
                                React.createElement('div', { className: "text-2xl font-bold text-purple-600" }, timeLeft),
                                React.createElement('div', { className: "text-sm text-purple-500" }, "æ®‹ã‚Šæ™‚é–“")
                            ),
                            React.createElement('div', { className: "bg-yellow-100 p-3 rounded-lg" },
                                React.createElement('div', { className: "text-2xl font-bold text-yellow-600" }, `ã‚¹ãƒ†ãƒ¼ã‚¸ ${stage}`),
                                React.createElement('div', { className: "text-sm text-yellow-500" }, "0ç‚¹ä»¥ä¸Šã§ã‚¯ãƒªã‚¢")
                            )
                        ),
                        React.createElement('div', { className: "bg-gray-200 rounded-full h-6 relative overflow-hidden mb-2" },
                            React.createElement('div', { 
                                className: `h-full rounded-full transition-all duration-500 ease-out relative ${
                                    score > stageConfig[stage].maxScore * 0.7 ? 'bg-gradient-to-r from-green-400 to-green-600' : 
                                    score > stageConfig[stage].maxScore * 0.4 ? 'bg-gradient-to-r from-yellow-400 to-yellow-600' : 
                                    'bg-gradient-to-r from-red-400 to-red-600'
                                }`,
                                style: { width: `${Math.min((score / stageConfig[stage].maxScore) * 100, 100)}%` }
                            },
                                React.createElement('div', { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent animate-pulse" })
                            ),
                            React.createElement('div', { className: "absolute top-0 left-0 w-1 h-full bg-red-700" }),
                            React.createElement('div', { className: "absolute top-0 right-0 w-1 h-full bg-yellow-500" })
                        ),
                        React.createElement('div', { className: "flex justify-between text-sm text-gray-600" },
                            React.createElement('span', null, `ç¾åœ¨: ${score}ç‚¹`),
                            React.createElement('span', { className: "text-yellow-600" }, `MAX: ${stageConfig[stage].maxScore}ç‚¹`)
                        )
                    ),
                    React.createElement('div', { className: "bg-white rounded-lg shadow-lg p-6 mb-6" },
                        React.createElement('div', { 
                            ref: gameAreaRef,
                            className: "relative w-full h-96 bg-gradient-to-b from-green-600 to-green-700 rounded-lg border-4 border-green-800 overflow-hidden",
                            style: { userSelect: 'none' },
                            onClick: handleGameAreaClick
                        },
                            React.createElement('div', { className: "absolute top-4 left-1/2 transform -translate-x-1/2 text-6xl font-bold text-green-900 opacity-30 pointer-events-none z-0" }, "ç‹¬å³¶"),
                            
                            characters.map((character) =>
                                React.createElement('div', {
                                    key: character.id,
                                    className: `absolute cursor-pointer transform -translate-x-1/2 -translate-y-1/2 hover:scale-110 ${
                                        character.type === 'good' 
                                            ? 'transition-all duration-300 ease-out'
                                            : 'transition-all duration-1000 ease-in-out'
                                    }`,
                                    style: { 
                                        left: `${character.x}px`, 
                                        top: `${character.y}px`,
                                        zIndex: 10
                                    },
                                    onClick: (e) => {
                                        e.stopPropagation();
                                        catchCharacter(character);
                                    }
                                },
                                    React.createElement('div', { 
                                        className: `text-4xl ${character.type === 'good' ? 'animate-bounce' : 'animate-pulse'}` 
                                    }, character.type === 'good' ? goodEmoji : badEmoji)
                                )
                            ),

                            tapEffects.map((effect) =>
                                React.createElement('div', {
                                    key: effect.id,
                                    className: "absolute transform -translate-x-1/2 -translate-y-1/2 pointer-events-none",
                                    style: { 
                                        left: `${effect.x}px`, 
                                        top: `${effect.y}px`,
                                        zIndex: 5
                                    }
                                },
                                    React.createElement('div', { className: "text-4xl opacity-80 animate-bounce" }, "ğŸ‘Ÿ")
                                )
                            ),

                            whackedPositions.map((pos) =>
                                React.createElement('div', {
                                    key: pos.id,
                                    className: "absolute transform -translate-x-1/2 -translate-y-1/2 pointer-events-none",
                                    style: { 
                                        left: `${pos.x}px`, 
                                        top: `${pos.y}px`,
                                        zIndex: 20
                                    }
                                },
                                    React.createElement('div', { className: "text-5xl opacity-90 animate-ping" }, "ğŸ’¥")
                                )
                            ),

                            bonusTexts.map((bonus) =>
                                React.createElement('div', {
                                    key: bonus.id,
                                    className: "absolute transform -translate-x-1/2 -translate-y-1/2 pointer-events-none",
                                    style: { 
                                        left: `${bonus.x}px`, 
                                        top: `${bonus.y}px`,
                                        zIndex: 25
                                    }
                                },
                                    React.createElement('div', { className: "text-2xl font-bold text-yellow-400 animate-bounce drop-shadow-lg" }, bonus.text)
                                )
                            ),

                            gameStatus === 'setup' && React.createElement('div', { className: "absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-lg" },
                                React.createElement('div', { className: "text-center text-white bg-black bg-opacity-70 p-6 rounded-lg" },
                                    React.createElement('div', { className: "text-4xl mb-4" }, "ğŸ®"),
                                    React.createElement('div', { className: "font-bold text-xl mb-2" }, t.gameReady),
                                    React.createElement('div', { className: "text-sm" }, t.pressStart)
                                )
                            ),

                            (gameStatus === 'gameOver' || gameStatus === 'stageCleared') && React.createElement('div', { className: "absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 rounded-lg" },
                                React.createElement('div', { className: "text-center text-white bg-black bg-opacity-80 p-8 rounded-lg max-w-sm" },
                                    gameStatus === 'stageCleared' ? (
                                        React.createElement('div', null,
                                            React.createElement('h3', { className: "text-3xl font-bold text-green-400 mb-4" }, "ğŸ‰ ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ ğŸ‰"),
                                            React.createElement('p', { className: "mb-6 text-lg" }, "0ç‚¹ä»¥ä¸Šã‚’ç¶­æŒã—ã¦ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼"),
                                            React.createElement('div', { className: "flex flex-col gap-3" },
                                                stage < 5 ? React.createElement('button', {
                                                    onClick: nextStage,
                                                    className: "bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg font-bold transition-colors text-lg"
                                                }, "æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸") : React.createElement('div', null,
                                                    React.createElement('h3', { className: "text-2xl font-bold text-yellow-400 mb-4" }, "ğŸ† å…¨ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ ğŸ†"),
                                                    React.createElement('p', { className: "mb-4" }, "ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼")
                                                ),
                                                React.createElement('button', {
                                                    onClick: resetGame,
                                                    className: "bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg font-bold flex items-center justify-center gap-2 transition-colors"
                                                }, React.createElement(RotateCcw, { size: 20 }), "ãƒªã‚»ãƒƒãƒˆ")
                                            )
                                        )
                                    ) : (
                                        React.createElement('div', null,
                                            React.createElement('h3', { className: "text-3xl font-bold text-red-400 mb-4" }, "ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ ğŸ’€"),
                                            React.createElement('p', { className: "mb-6 text-lg" }, 
                                                score > 0 ? `æ™‚é–“åˆ‡ã‚Œï¼ æ®‹ã‚Š${score}ç‚¹` : `ã‚¹ã‚³ã‚¢0ç‚¹ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼`
                                            ),
                                            React.createElement('div', { className: "flex flex-col gap-3" },
                                                score > 0 && stage < 5 && React.createElement('button', {
                                                    onClick: nextStage,
                                                    className: "bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg font-bold transition-colors text-lg"
                                                }, "æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸"),
                                                React.createElement('button', {
                                                    onClick: resetGame,
                                                    className: "bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg font-bold flex items-center justify-center gap-2 transition-colors"
                                                }, React.createElement(RotateCcw, { size: 20 }), "ãƒªã‚»ãƒƒãƒˆ")
                                            )
                                        )
                                    )
                                )
                            )
                        ),

                        React.createElement('div', { className: "flex justify-center gap-4 mt-4" },
                            gameStatus === 'setup' && React.createElement('button', {
                                onClick: startGame,
                                className: "bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg font-bold flex items-center gap-2 transition-colors"
                            }, React.createElement(Play, { size: 20 }), t.startButton)
                        )
                    ),

                    React.createElement('div', { className: "bg-white rounded-lg shadow-lg p-6" },
                        React.createElement('h3', { className: "font-bold mb-2" }, "ã‚²ãƒ¼ãƒ ã®éŠã³æ–¹"),
                        React.createElement('div', { className: "mb-4 p-3 bg-blue-50 rounded-lg" },
                            React.createElement('p', { className: "text-sm text-blue-700 font-semibold mb-2" }, "ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼:"),
                            React.createElement('div', { className: "flex justify-center gap-8" },
                                React.createElement('div', { className: "text-center" },
                                    React.createElement('div', { className: "text-3xl mb-1" }, "ğŸ‡¯ğŸ‡µ"),
                                    React.createElement('div', { className: "text-xs text-blue-600 font-semibold" }, "è¨ã¡å–ã‚‹å¯¾è±¡"),
                                    React.createElement('div', { className: "text-xs text-gray-500" }, "+20ã€œ40ç‚¹ / é€ƒã™ã¨-200ç‚¹")
                                ),
                                React.createElement('div', { className: "text-center" },
                                    React.createElement('div', { className: "text-3xl mb-1" }, "ğŸ‡°ğŸ‡·"),
                                    React.createElement('div', { className: "text-xs text-red-600 font-semibold" }, "çµ¶å¯¾é¿ã‘ã‚‹"),
                                    React.createElement('div', { className: "text-xs text-gray-500" }, "è¸ã‚€ã¨å³åº§ã«0ç‚¹")
                                )
                            )
                        ),
                        React.createElement('ul', { className: "text-sm text-gray-700 space-y-1" },
                            React.createElement('li', null, "â€¢ ğŸ‡¯ğŸ‡µã‚’è¨ã¡å–ã‚‹ã¨+20ã€œ40ç‚¹ã€é€ƒã™ã¨-200ç‚¹ã®å¤§å¹…æ¸›ç‚¹"),
                            React.createElement('li', null, "â€¢ ğŸ‡°ğŸ‡·ã‚’è¸ã‚€ã¨å³åº§ã«0ç‚¹ï¼ˆä¸€ç™ºã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼‰"),
                            React.createElement('li', null, "â€¢ ã‚¹ã‚³ã‚¢ãŒ0ã«ãªã£ãŸç¬é–“ã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼"),
                            React.createElement('li', null, "â€¢ ã‚¹ãƒ†ãƒ¼ã‚¸ãŒä¸ŠãŒã‚‹ã«ã¤ã‚Œã¦ğŸ‡¯ğŸ‡µã®ç§»å‹•é€Ÿåº¦ãŒä¸ŠãŒã‚‹"),
                            React.createElement('li', null, "â€¢ åˆ¶é™æ™‚é–“ãŒçŸ­ãã€éå¸¸ã«æˆ¦ç•¥çš„ãªãƒ—ãƒ¬ã‚¤ãŒå¿…è¦"),
                            React.createElement('li', null, "â€¢ åˆ¶é™æ™‚é–“å†…ã«ã‚¹ã‚³ã‚¢ãŒ1ç‚¹ä»¥ä¸Šæ®‹ã‚Œã°ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢")
                        )
                    )
                )
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(FlySwatterGame));
    </script>
</body>
</html>1000, time: 20, spawnRate: 1000, maxCharacters: 6 },
                2: { startScore: 700, maxScore: 1400, time: 25, spawnRate: 900, maxCharacters: 8 },
                3: { startScore: 900, maxScore: 1800, time: 30, spawnRate: 800, maxCharacters: 10 },
                4: { startScore: 1100, maxScore: 2200, time: 35, spawnRate: 700, maxCharacters: 12 },
                5: { startScore: 1300, maxScore: 2600, time: 40, spawnRate: 600, maxCharacters: 15 }
            };

            const getRandomPosition = () => {
                const margin = 50;
                const x = Math.random() * (400 - margin * 2) + margin;
                const y = Math.random() * (400 - margin * 2) + margin;
                return { x, y };
            };

            const moveCharacter = (characterId) => {
                setCharacters(prev => prev.map(char => {
                    if (char.id === characterId) {
                        const newPosition = getRandomPosition();
                        return { ...char, ...newPosition };
                    }
                    return char;
                }));
            };

            const continuousMove = (characterId) => {
                const moveStep = () => {
                    setCharacters(prev => prev.map(char => {
                        if (char.id === characterId && char.type === 'bad') {
                            const deltaX = (Math.random() - 0.5) * 30;
                            const deltaY = (Math.random() - 0.5) * 30;
                            
                            const margin = 50;
                            const newX = Math.max(margin, Math.min(350, char.x + deltaX));
                            const newY = Math.max(margin, Math.min(350, char.y + deltaY));
                            
                            return { ...char, x: newX, y: newY };
                        }
                        return char;
                    }));
                };

                const continuousTimer = setInterval(moveStep, 100);
                return continuousTimer;
            };

            const spawnCharacter = () => {
                const config = stageConfig[stage];
                if (characters.length >= config.maxCharacters) return;

                const isGoodCharacter = Math.random() > 0.5;
                const points = isGoodCharacter ? Math.floor(Math.random() * 20) + 20 : 0;
                const position = getRandomPosition();
                const newCharacter = {
                    id: Date.now() + Math.random(),
                    type: isGoodCharacter ? 'good' : 'bad',
                    points,
                    ...position,
                    createdAt: Date.now()
                };

                setCharacters(prev => [...prev, newCharacter]);

                let moveTimer, continuousTimer;

                if (isGoodCharacter) {
                    const baseSpeed = 800 - (stage - 1) * 150;
                    const randomVariation = Math.random() * 200;
                    const moveSpeed = Math.max(200, baseSpeed + randomVariation);
                    
                    moveTimer = setInterval(() => {
                        if (gameStatus === 'playing') {
                            moveCharacter(newCharacter.id);
                        }
                    }, moveSpeed);
                } else {
                    continuousTimer = continuousMove(newCharacter.id);
                }

                const removeTimer = setTimeout(() => {
                    setCharacters(prev => {
                        const character = prev.find(char => char.id === newCharacter.id);
                        if (character && character.type === 'good') {
                            setScore(current => Math.max(0, current - 200));
                        }
                        return prev.filter(char => char.id !== newCharacter.id);
                    });
                    if (moveTimer) clearInterval(moveTimer);
                    if (continuousTimer) clearInterval(continuousTimer);
                }, isGoodCharacter ? 4000 + Math.random() * 2000 : 10000 + Math.random() * 5000);

                characterTimersRef.current[newCharacter.id] = { 
                    moveInterval: moveTimer || continuousTimer, 
                    removeTimer 
                };
            };

            const catchCharacter = (character) => {
                if (gameStatus !== 'playing') return;

                const hitEffect = { x: character.x, y: character.y, id: Date.now() };
                setWhackedPositions(prev => [...prev, hitEffect]);
                
                setTimeout(() => {
                    setWhackedPositions(prev => prev.filter(pos => pos.id !== hitEffect.id));
                }, 600);

                if (character.type === 'good') {
                    const config = stageConfig[stage];
                    const newScore = Math.min(config.maxScore, score + character.points);
                    setScore(newScore);
                    
                    const bonusTexts = ['ï¾ƒï¾Šï¾ï¾ï¾ï½¸ï¾ï½¸ï¾ï¾ï½¾', 'ï½²ï¾™ï¾ï¾ï¾ï¾ï½­ï½ºï¾ï¾—', 'ï½»ï½½ï½¶ï¾', 'ï¾ï½®ï½±', 'ï¾ï¾ï½¾'];
                    const randomText = bonusTexts[Math.floor(Math.random() * bonus
